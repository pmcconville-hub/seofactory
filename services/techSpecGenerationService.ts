/**
 * Tech Spec Generation Service
 *
 * Generates technical deliverables from existing pipeline data:
 * URL list, redirect map, meta tag templates, XML sitemap,
 * robots.txt, navigation spec, performance targets, and image spec.
 *
 * Created: 2026-02-19 - Pipeline tech spec step
 *
 * @module services/techSpecGenerationService
 */

import type { TopicalMap, EnrichedTopic, ContentBrief } from '../types';

// ============================================================================
// TYPES
// ============================================================================

/**
 * A single deliverable file generated by the tech spec service.
 */
export interface TechSpecDeliverable {
  /** Human-readable name of the deliverable */
  name: string;
  /** File format (csv, xml, txt, md) */
  format: string;
  /** The generated file content as a string */
  content: string;
  /** Suggested filename for export */
  filename: string;
}

/**
 * Result of the tech spec generation process.
 */
export interface TechSpecResult {
  /** All generated deliverables */
  deliverables: TechSpecDeliverable[];
  /** ISO timestamp of when the spec was generated */
  generatedAt: string;
}

// ============================================================================
// HELPERS
// ============================================================================

/**
 * Converts a topic title to a URL-safe slug.
 */
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

/**
 * Escapes a value for CSV output (wraps in quotes if it contains commas, quotes, or newlines).
 */
function csvEscape(value: string): string {
  if (value.includes(',') || value.includes('"') || value.includes('\n')) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}

/**
 * Builds a full URL from domain and slug.
 */
function buildUrl(domain: string, slug: string): string {
  const cleanDomain = domain.replace(/\/+$/, '');
  const protocol = cleanDomain.startsWith('http') ? '' : 'https://';
  return `${protocol}${cleanDomain}/${slug}`;
}

/**
 * Determines the cluster/parent name for a topic.
 */
function getClusterName(
  topic: EnrichedTopic,
  topicsById: Map<string, EnrichedTopic>
): string {
  if (topic.parent_topic_id) {
    const parent = topicsById.get(topic.parent_topic_id);
    return parent?.title ?? 'Unknown Cluster';
  }
  return topic.cluster_role === 'pillar' ? topic.title : 'Unclustered';
}

// ============================================================================
// DELIVERABLE GENERATORS
// ============================================================================

/**
 * Generates a CSV of all topic URLs with metadata.
 */
function generateUrlList(
  topics: EnrichedTopic[],
  domain: string,
  topicsById: Map<string, EnrichedTopic>
): TechSpecDeliverable {
  const header = 'url,title,type,topic_class,cluster_role,cluster,slug';
  const rows = topics.map((topic) => {
    const slug = topic.slug || slugify(topic.title);
    const url = buildUrl(domain, slug);
    const cluster = getClusterName(topic, topicsById);
    return [
      csvEscape(url),
      csvEscape(topic.title),
      csvEscape(topic.type),
      csvEscape(topic.topic_class ?? ''),
      csvEscape(topic.cluster_role ?? ''),
      csvEscape(cluster),
      csvEscape(slug),
    ].join(',');
  });

  return {
    name: 'URL List',
    format: 'csv',
    content: [header, ...rows].join('\n'),
    filename: 'url-list.csv',
  };
}

/**
 * Generates a placeholder redirect map CSV.
 */
function generateRedirectMap(): TechSpecDeliverable {
  const header = 'old_url,new_url,redirect_type';
  const placeholder =
    '# Add redirects below. Format: old URL, new URL, redirect type (301 or 302)';
  const example = '/old-page-example,/new-page-example,301';

  return {
    name: 'Redirect Map',
    format: 'csv',
    content: [header, placeholder, example].join('\n'),
    filename: 'redirect-map.csv',
  };
}

/**
 * Generates meta tag templates CSV with one row per page type.
 */
function generateMetaTagTemplates(
  topics: EnrichedTopic[],
  domain: string,
  centralEntity: string
): TechSpecDeliverable {
  const header =
    'page_type,title_template,meta_description_template,og_title_template,example_title';

  // Collect unique page types
  const pageTypes = new Set<string>();
  for (const topic of topics) {
    const pageType = `${topic.type}_${topic.topic_class ?? 'general'}`;
    pageTypes.add(pageType);
  }

  const rows: string[] = [];

  // Generate template for each page type
  for (const pageType of pageTypes) {
    let titleTemplate: string;
    let metaTemplate: string;

    if (pageType.includes('monetization')) {
      titleTemplate = `{Topic Title} | ${centralEntity} - ${domain}`;
      metaTemplate = `Discover {topic_title} for ${centralEntity}. Expert guide with pricing, comparisons, and actionable advice.`;
    } else if (pageType.includes('informational')) {
      titleTemplate = `{Topic Title} - Complete Guide | ${domain}`;
      metaTemplate = `Learn everything about {topic_title}. In-depth guide covering key concepts, best practices, and expert insights.`;
    } else if (pageType.includes('outer')) {
      titleTemplate = `{Topic Title} | ${centralEntity} Insights - ${domain}`;
      metaTemplate = `Explore {topic_title} and how it relates to ${centralEntity}. Expert analysis and practical recommendations.`;
    } else {
      titleTemplate = `{Topic Title} | ${domain}`;
      metaTemplate = `{topic_title} - comprehensive coverage from ${domain}.`;
    }

    rows.push(
      [
        csvEscape(pageType),
        csvEscape(titleTemplate),
        csvEscape(metaTemplate),
        csvEscape(titleTemplate),
        csvEscape(titleTemplate.replace('{Topic Title}', 'Example Topic')),
      ].join(',')
    );
  }

  return {
    name: 'Meta Tag Templates',
    format: 'csv',
    content: [header, ...rows].join('\n'),
    filename: 'meta-tag-templates.csv',
  };
}

/**
 * Generates a standard XML sitemap with all topic URLs.
 */
function generateXmlSitemap(
  topics: EnrichedTopic[],
  domain: string
): TechSpecDeliverable {
  const today = new Date().toISOString().split('T')[0];

  const urlEntries = topics.map((topic) => {
    const slug = topic.slug || slugify(topic.title);
    const url = buildUrl(domain, slug);
    const priority =
      topic.cluster_role === 'pillar'
        ? '0.9'
        : topic.type === 'core'
          ? '0.7'
          : '0.5';
    const changefreq =
      topic.cluster_role === 'pillar' ? 'weekly' : 'monthly';

    return `  <url>
    <loc>${escapeXml(url)}</loc>
    <lastmod>${today}</lastmod>
    <changefreq>${changefreq}</changefreq>
    <priority>${priority}</priority>
  </url>`;
  });

  const xml = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>${escapeXml(buildUrl(domain, ''))}</loc>
    <lastmod>${today}</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>
${urlEntries.join('\n')}
</urlset>`;

  return {
    name: 'XML Sitemap',
    format: 'xml',
    content: xml,
    filename: 'sitemap.xml',
  };
}

/**
 * Escapes special characters for XML content.
 */
function escapeXml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}

/**
 * Generates a standard robots.txt with sitemap reference.
 */
function generateRobotsTxt(domain: string): TechSpecDeliverable {
  const sitemapUrl = buildUrl(domain, 'sitemap.xml');

  const content = `# robots.txt generated by Holistic SEO Topical Map Generator
# ${new Date().toISOString().split('T')[0]}

User-agent: *
Allow: /

# Sitemap
Sitemap: ${sitemapUrl}

# Disallow admin/system paths
User-agent: *
Disallow: /api/
Disallow: /admin/
Disallow: /_next/
Disallow: /search?
`;

  return {
    name: 'robots.txt',
    format: 'txt',
    content,
    filename: 'robots.txt',
  };
}

/**
 * Generates a navigation specification in Markdown.
 */
function generateNavigationSpec(
  topics: EnrichedTopic[],
  map: TopicalMap
): TechSpecDeliverable {
  const centralEntity =
    map.pillars?.centralEntity ?? map.name ?? 'Main Topic';

  // Group pillar topics for main navigation
  const pillars = topics.filter((t) => t.cluster_role === 'pillar');
  const corePillars = pillars.filter((t) => t.type === 'core');
  const outerPillars = pillars.filter((t) => t.type === 'outer');

  let content = `# Navigation Specification\n\n`;
  content += `**Central Entity:** ${centralEntity}\n`;
  content += `**Generated:** ${new Date().toISOString().split('T')[0]}\n\n`;

  // Main Navigation
  content += `## Main Navigation\n\n`;
  content += `| Position | Label | Target | Notes |\n`;
  content += `|----------|-------|--------|-------|\n`;
  content += `| 1 | Home | / | Homepage |\n`;

  let position = 2;
  for (const pillar of corePillars.slice(0, 6)) {
    const slug = pillar.slug || slugify(pillar.title);
    content += `| ${position} | ${pillar.title} | /${slug} | Core pillar |\n`;
    position++;
  }

  content += `| ${position} | About | /about | Foundation page |\n`;
  content += `| ${position + 1} | Contact | /contact | Foundation page |\n`;

  // Footer Navigation
  content += `\n## Footer Navigation\n\n`;
  content += `### Column 1: Core Topics\n\n`;
  for (const pillar of corePillars.slice(0, 5)) {
    const slug = pillar.slug || slugify(pillar.title);
    content += `- [${pillar.title}](/${slug})\n`;
  }

  content += `\n### Column 2: Resources\n\n`;
  for (const pillar of outerPillars.slice(0, 5)) {
    const slug = pillar.slug || slugify(pillar.title);
    content += `- [${pillar.title}](/${slug})\n`;
  }

  content += `\n### Column 3: Company\n\n`;
  content += `- [About](/about)\n`;
  content += `- [Contact](/contact)\n`;
  content += `- [Privacy Policy](/privacy)\n`;
  content += `- [Terms of Service](/terms)\n`;

  return {
    name: 'Navigation Spec',
    format: 'md',
    content,
    filename: 'navigation-spec.md',
  };
}

/**
 * Generates performance targets in Markdown.
 */
function generatePerformanceTargets(): TechSpecDeliverable {
  const content = `# Performance Targets

## Core Web Vitals

| Metric | Target | Threshold |
|--------|--------|-----------|
| LCP (Largest Contentful Paint) | < 2.5s | Good |
| INP (Interaction to Next Paint) | < 200ms | Good |
| CLS (Cumulative Layout Shift) | < 0.1 | Good |

## Additional Targets

| Metric | Target | Notes |
|--------|--------|-------|
| TTFB (Time to First Byte) | < 800ms | Server response time |
| FCP (First Contentful Paint) | < 1.8s | First visual content |
| Total Page Weight | < 1.5MB | Including all resources |
| DOM Size | < 1500 nodes | Avoid excessive nesting |
| Image Compression | AVIF/WebP | With JPEG/PNG fallback |
| HTTP Requests | < 50 | Per page load |

## Image Guidelines

- Use AVIF as primary format with WebP and JPEG fallbacks
- Implement responsive images with \`srcset\` and \`sizes\`
- Lazy load below-the-fold images
- Include width and height attributes to prevent CLS
- Compress images to < 100KB for standard content images
- Hero images should be < 200KB

## Caching Strategy

| Resource Type | Cache Duration | Notes |
|--------------|---------------|-------|
| HTML | no-cache | Always revalidate |
| CSS/JS | 1 year | Use content hashing |
| Images | 1 year | Use content hashing |
| Fonts | 1 year | Immutable |
| API responses | 5 minutes | stale-while-revalidate |

## Monitoring

- Set up RUM (Real User Monitoring) via CrUX or web-vitals library
- Configure alerts for CWV regression (> 10% degradation)
- Run Lighthouse CI on every deployment
- Track TTFB by geography for CDN optimization
`;

  return {
    name: 'Performance Targets',
    format: 'md',
    content,
    filename: 'performance-targets.md',
  };
}

/**
 * Generates an image spec placeholder CSV.
 */
function generateImageSpec(topics: EnrichedTopic[]): TechSpecDeliverable {
  const header =
    'page_slug,image_type,alt_text,caption,format,max_width_px,notes';
  const rows: string[] = [];

  for (const topic of topics) {
    const slug = topic.slug || slugify(topic.title);

    // Featured image placeholder
    rows.push(
      [
        csvEscape(slug),
        'featured',
        csvEscape(`Featured image for ${topic.title}`),
        csvEscape(topic.title),
        'avif,webp,jpg',
        '1200',
        'Hero/featured image',
      ].join(',')
    );

    // In-content image placeholder for pillar topics
    if (topic.cluster_role === 'pillar') {
      rows.push(
        [
          csvEscape(slug),
          'in-content',
          csvEscape(`Infographic explaining key concepts of ${topic.title}`),
          csvEscape(`Key concepts of ${topic.title}`),
          'avif,webp,png',
          '800',
          'Infographic or diagram',
        ].join(',')
      );
    }
  }

  return {
    name: 'Image Spec',
    format: 'csv',
    content: [header, ...rows].join('\n'),
    filename: 'image-spec.csv',
  };
}

// ============================================================================
// MAIN GENERATION FUNCTION
// ============================================================================

/**
 * Generates the complete set of technical deliverables from pipeline data.
 *
 * @param map - The topical map containing business info, pillars, and domain
 * @param topics - All enriched topics in the map
 * @param briefs - Content briefs keyed by topic ID
 * @returns TechSpecResult with all generated deliverables
 */
export async function generateTechSpec(
  map: TopicalMap,
  topics: EnrichedTopic[],
  briefs: Record<string, ContentBrief>
): Promise<TechSpecResult> {
  const domain =
    map.domain ??
    map.business_info?.domain ??
    'example.com';

  const centralEntity =
    map.pillars?.centralEntity ?? map.name ?? 'Main Topic';

  // Build a lookup map for cluster resolution
  const topicsById = new Map<string, EnrichedTopic>();
  for (const topic of topics) {
    topicsById.set(topic.id, topic);
  }

  // Generate all deliverables
  const deliverables: TechSpecDeliverable[] = [
    generateUrlList(topics, domain, topicsById),
    generateRedirectMap(),
    generateMetaTagTemplates(topics, domain, centralEntity),
    generateXmlSitemap(topics, domain),
    generateRobotsTxt(domain),
    generateNavigationSpec(topics, map),
    generatePerformanceTargets(),
    generateImageSpec(topics),
  ];

  return {
    deliverables,
    generatedAt: new Date().toISOString(),
  };
}
